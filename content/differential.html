<!DOCTYPE html>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>differential</title>
<style>
html, body {
	margin: 0;
	padding: 0;
}

html, body, input {
	font-family: "Segoe UI", -apple-system, "Helvetica", "Segoe UI Emoji", "Apple Color Emoji", "Noto Color Emoji", "Noto Sans",  "FreeSans", "Code2001", "Code2000", "DejaVu Sans",  sans-serif;
	color: #222;
	font-size: 18px;
}

input {
	font-size: 16px;
}

p {
	margin: 1em 0;
}

ul > li {
	list-style: none;
}

ul > li:before {
	content: '→';
	position: relative;
	right: 1em;
}

code {
	font-family: monospace;
	background-color: #ddd;
}

/* better underline with gradients */
a, a:visited {
	color: #226;
	text-decoration: none;
	position: relative;
	background-image: linear-gradient(to bottom,rgba(0,0,0,0) 50%,rgba(34,34,102,0.8) 50%);
	background-repeat: repeat-x;
	background-size: 2px 0.1em;
	background-position: 0 1.15em;
}

a:hover {
	color: #b26;
	background-image: linear-gradient(to bottom,rgba(0,0,0,0) 50%,rgba(187,34,102,0.8) 50%);
}

#container {
	margin: 50px auto;
	max-width: 1200px;
}

canvas {
	cursor: move;
	cursor: -webkit-grab;
	display: block;
	margin: auto;
}

#controls {
	max-width: 600px;
	margin: auto;
}

#formula-input {
	width: 80%;
	float: right;
}

input[type="range"] {
	margin: 0 auto;
	width: 100%;
	max-width: 100%;
	position: relative;
	top: 6px;
}

input[type="number"] {
	width: 25%;
	max-width: 50px;
	float: right;
}

#formula-note {
	display: none;
	margin-bottom: 1em;
	padding: 1em;
	border: 1px solid #999;
}

#formula-note > p:last-child {
	margin-bottom: 0;
}

.hidden {
	display: none;
}

@media (min-width: 1000px) {
	#container {
		max-width: 1000px;
	}

	canvas, #controls {
		display: inline-block;
	}

	#controls {
		max-width: 445px;
		margin-left: 50px;
		vertical-align: top;
		width: 100%;
	}
}

@media (max-width: 600px) {
	#container {
		margin: 20px;
	}

	canvas {
		margin-bottom: 1em;
		max-width: 100%;
		height: auto!important;
	}
}

</style>
<body onload="init()">
<div id="container">
	<canvas id="main-canvas"></canvas>
	<div id="controls">
		<p><sup>dy</sup>⁄<sub>dx</sub> = <input type="text" id="formula-input" value="y + sin(x)"></input>

		<div id="formula-note">
			<p><b>Note:</b> Because of the architecture of this
			program, in <sup>dy</sup>⁄<sub>dx</sub>, carets
			(<code>^</code>) represent the logical <a
			href="https://en.m.wikipedia.org/wiki/Exclusive_or">xor</a>
			operation and <i>not</i> exponentiation.  <p>For
			exponents, use <code>pow(base, exponent)</code> —
			“x²”, for example, would be written as <code>pow(x,
			2)</code> <p><button id="got-it">Got it.</button>
		</div>

		<br>Slope field density:
		<input type="number" id="grid-spacing-value" value="20">
		<br><input type="range" id="grid-spacing-range" min="1" max="100" value="20" step="0.01"></input>

		<div class="hidden"><p>Graph:
		<br>Width:
		<input type="number" id="width-value" value="10">
		<br><input type="range" id="width-range" min="0.01" max="50" value="10" step="0.01"></input>

		<p>Height:
		<input type="number" id="height-value" value="10">
		<br><input type="range" id="height-range" min="0.01" max="50" value="10" step="0.01"></input>

		<p>Center:
		<br>x:
		<input type="number" id="center-x-value" value="0">
		<br><input type="range" id="center-x-range" min="-10" max="10" value="0" step="0.01"></input>

		<br>y:
		<input type="number" id="center-y-value" value="0">
		<br><input type="range" id="center-y-range" min="-10" max="10" value="0" step="0.01"></input></div>

		<p> differential uses <a href="https://en.m.wikipedia.org/wiki/Euler_method">
		the Euler method</a> of differential equation approximation,
		and as such may yield strange or erroneous solutions for
		equations with asymptotes, discontinuities, or no real
		solution for y(x) = …, such as
		<a href="#%2Dx%2Fy" onclick="setEqFromURL()">
		<sup>dy</sup>⁄<sub>dx</sub> = -<sup>x</sup>⁄<sub>y<sub></a>

		<p> note that differential is ultimately a toy! do not blame
		me if you use it for your homework and it messes up

		<p> check out:
		<ul>
			<li><a href="#tanx%20cosy" onclick="setEqFromURL()">
			<sup>dy</sup>⁄<sub>dx</sub> = tanx cosy</li>
			<li><a href="#x%20*%20y" onclick="setEqFromURL()">
			<sup>dy</sup>⁄<sub>dx</sub> = x · y</li>
			<li><a href="#sqrt(pow(x%2C%202)%20%2B%20pow(y%2C%202))%20-%204" onclick="setEqFromURL()">
			<sup>dy</sup>⁄<sub>dx</sub> = sqrt(x<sup>2</sup> + y<sup>2</sup>)</li>
		</ul>
	</div>
</div>
<script>
//jquery lite™
//sorry
function $(id) { return document.getElementById(id); }

//globals
let background,
	touched,
	frame,
	screen,
	pixelScale,
	graph,
	step,
	cursorTracking,
	cursor,
	lastTouch,
	formula,
	partitions,
	bottomLimit,
	topLimit,
	flipped,
	lastRender,
	continuous,
	mode,
	gotIt,
	gridSpacing;

function colorToRgba(color) {
	return 'rgba('
		+ color[0] + ','
		+ color[1] + ','
		+ color[2] + ','
		+ color[3] + ')';
}

function drawLine(x, y, endx, endy, color) {
	// archive color to restore canvas to original state
	let prevColor = ctx.strokeStyle;
	ctx.beginPath();
	ctx.moveTo(x, y);
	ctx.lineTo(endx, endy);
	ctx.strokeStyle = color;
	ctx.stroke();
	ctx.strokeStyle = prevColor;
}

function drawSharpLine(x, y, endx, endy, color) {
	drawLine(
		Math.floor(x) + 0.5,
		Math.floor(y) + 0.5,
		Math.floor(endx) + 0.5,
		Math.floor(endy) + 0.5,
		color
	);
}

function round(val) {
	return val.toPrecision(3);
}

function screenToGraphY(y) {
	//transform screen coords to graph coords
	return (y / ctx.y) * graph.y.range + graph.y.min;
}

function screenToGraphX(x) {
	return -(x / ctx.x) * graph.x.range - graph.x.min;
}

function graphToScreenY(y) {
	//reverse
	return ctx.y - (y - graph.y.min) / graph.y.range * ctx.y;
}

function graphToScreenX(x) {
	return (x - graph.x.min) / graph.x.range * ctx.x;
}

function getdydx(x, y) {
	//x, y in graph to dy/dx
	try {
		return eval(formula);
	} catch(e) {
		return NaN;
	}
}

function getTickStep(width) {
	//get the number's exponent
	let exponent = Math.floor(Math.log10(width));
	//by raising it to -log x, we can "normalize" it to a number
	//from 1 to 10, which we can round to 2.5
	//and then raise (or lower) it to its original exponent - 1
	//(to make it approx. 1/10th of the screen's width)
	let normal = width * Math.pow(10, -exponent);
	let tickStep = Math.ceil(normal / 2.5) * 2.5
		* Math.pow(10, exponent - 1);
	return tickStep;
}

function renderGrid() {
	let color = colorToRgba([0, 0, 0, 1]);
	let increment = graph.x.range / gridSpacing;
	let xOfs = -graph.x.min % increment;
	let yOfs = -graph.y.min % increment;
	let tickLength = 10;
	let dydx, theta, cost, sint;
	for(let y = graph.y.min + yOfs; y < graph.y.max; y += increment) {
	for(let x = graph.x.min + xOfs; x < graph.x.max; x += increment) {
		dydx = getdydx(x, y);
		theta = Math.atan(dydx);
		slope_x = tickLength * Math.cos(theta);
		slope_y = tickLength * Math.sin(theta);
		drawLine(
			graphToScreenX(x) - slope_x,
			graphToScreenY(y) + slope_y,
			graphToScreenX(x) + slope_x,
			graphToScreenY(y) - slope_y,
			color
		);
	}
	}
}

function renderSolution() {
	// get cursor pos. in graph coords
	let startx = cursor.x;
	let starty = cursor.y;
	let color = colorToRgba([255, 0, 0, 1]);
	// divide graph range into slices
	let dx = graph.x.range / ctx.x;
	let y = starty;
	// previous y, for asymptote checking
	let y_p = y;
	let x = startx;
	let dydx, dydx_p;
	dydx_p = dydx = getdydx(x, y);

	ctx.fillStyle = color;
	ctx.textBaseline = 'middle';
	ctx.textAlign = 'left';
	ctx.fillText('(' + startx.toPrecision(3)
		+   ', ' + starty.toPrecision(3) + ')',
		graphToScreenX(startx) + 15 * pixelScale,
		graphToScreenY(starty)
	);
	ctx.fillText('dy/dx = ' + dydx.toPrecision(3),
		graphToScreenX(startx) + 15 * pixelScale,
		graphToScreenY(starty) + 18 * pixelScale
	);

	let flip = () => {
		// flip dx so we're traveling from right to left
		dx *= -1;
		// finish path, reset coords
		ctx.stroke();
		ctx.moveTo(startx, starty);
		ctx.beginPath();
		x = startx;
		y = y_p = starty;
		dydx_p = dydx = getdydx(x, y);
	};

	if(
		   (cursor.x > graph.x.max)
		|| (cursor.x < graph.x.min)
		|| (cursor.y > graph.y.max)
		|| (cursor.y < graph.y.min)
	) {
		//out of bounds!
		return;
	}

	// use euler’s method
	// move right, then left
	ctx.strokeStyle = color;
	ctx.moveTo(graphToScreenX(startx), graphToScreenY(starty));
	ctx.beginPath();
	while(x += dx) {
		dydx = getdydx(x, y);
		y += dydx * dx;

		// out of bounds (10 window-lengths above or below the window)
		// don’t be fooled by the next if(), this catches most of
		// the asymptotes
		if(
			   (y >= graph.y.max + 5 * graph.y.range)
			|| (y <= graph.y.min - 5 * graph.y.range)
			|| (isNaN(y))
			|| (!isFinite(y))
		) {
			//console.log(x + ', ' + y);
			// one last line so the graph doesn’t dissapear
			// mid-graph
			//ctx.fillText("OOB", graphToScreenX(x - dx), graphToScreenY(y_p));
			if(!isNaN(y) && isFinite(y)) {
				y = ctx.y;
				if(
					((dydx_p > 0) && (dx > 0)) ||
					((dydx_p < 0) && (dx < 0))
				) { y *= -1; }
				ctx.lineTo(graphToScreenX(x), y);
			}
			if(dx >= 0) {
				flip();
				continue;
			} else {
				break;
			}
		}

		// asymptote is defined as the slope changing sign and being
		// of a large magnitude
		// not bullet-proof but better than nothing
		// euler’s method doesn’t really work across asymptotes
		// (although it will usually get the graph shape right) so
		// we just call it quits
		if((Math.sign(dydx) === -Math.sign(dydx_p))
			&& (Math.abs(dydx) >= 20)
		) {
			//ctx.fillText("SLOPE", graphToScreenX(x), graphToScreenY(y_p));
			break;
		} else {
			//console.log(x + ', ' + y);
			ctx.lineTo(graphToScreenX(x), graphToScreenY(y));
		}

		if(x >= graph.x.max) {
			// start over, reverse direction
			flip();
		} else if(x <= graph.x.min) {
			break;
		}

		dydx_p = dydx;
		y_p = y;
	}
	ctx.stroke();
}

function renderDecoration() {
	let decorationColor = colorToRgba([0, 0, 0, 0.5]);

	let xTickStep = getTickStep(graph.x.range);
	let yTickStep = getTickStep(graph.y.range);

	ctx.fillStyle   = decorationColor;
	ctx.strokeStyle = decorationColor;
	//draw x axis
	drawLine(
		Math.floor(graphToScreenX(graph.x.min)) - 0.5,
		Math.floor(graphToScreenY(0)) + 0.5,
		Math.floor(graphToScreenX(graph.x.max)) + 0.5,
		Math.floor(graphToScreenY(0)) + 0.5,
		decorationColor
	);
	//draw y axis
	drawLine(
		Math.floor(graphToScreenX(0)) + 0.5,
		Math.floor(graphToScreenY(graph.y.min)) - 0.5,
		Math.floor(graphToScreenX(0)) + 0.5,
		Math.floor(graphToScreenY(graph.y.max)) + 0.5,
		decorationColor
	);
	//draw ticks
	for(let i = graph.x.min - graph.x.min % xTickStep; i < graph.x.max + xTickStep; i += xTickStep) {
		drawSharpLine(
			graphToScreenX(i),
			graphToScreenY(0),
			graphToScreenX(i),
			graphToScreenY(graph.y.range / 50),
			decorationColor
		);
	}
	for(let i = graph.y.min - graph.y.min % yTickStep; i < graph.y.max + yTickStep; i += yTickStep) {
		drawSharpLine(
			graphToScreenX(0),
			graphToScreenY(i),
			graphToScreenX(graph.x.range / 50),
			graphToScreenY(i),
			decorationColor
		);
	}

	//draw tick width indicator at bottom
	let xTickWidthOnScreen = graphToScreenX(xTickStep) - graphToScreenX(0);
	//y axis is reversed relative to canvas axis so we flip it
	let yTickWidthOnScreen = -graphToScreenY(yTickStep) + graphToScreenY(0);
	//top line
	drawSharpLine(
		ctx.x - xTickWidthOnScreen - 2 * pixelScale, 2 * pixelScale,
		ctx.x - 2 * pixelScale, 2 * pixelScale,
		decorationColor
	);
	//x tick
	drawSharpLine(
		ctx.x - xTickWidthOnScreen - 2 * pixelScale, 2 * pixelScale,
		ctx.x - xTickWidthOnScreen - 2 * pixelScale, 6 * pixelScale,
		decorationColor
	);
	//x tick text
	ctx.textBaseline = 'top';
	ctx.textAlign = 'center';
	ctx.fillText(xTickStep,
		ctx.x - xTickWidthOnScreen, 8 * pixelScale
	);
	//right line
	drawSharpLine(
		ctx.x - 2 * pixelScale, 2 * pixelScale,
		ctx.x - 2 * pixelScale, yTickWidthOnScreen + 2 * pixelScale,
		decorationColor
	);
	//y tick
	drawSharpLine(
		ctx.x - 2 * pixelScale, yTickWidthOnScreen + 2 * pixelScale,
		ctx.x - 6 * pixelScale, yTickWidthOnScreen + 2 * pixelScale,
		decorationColor
	);
	//y tick text
	ctx.textBaseline = 'middle';
	ctx.textAlign = 'right';
	ctx.fillText(yTickStep,
		ctx.x - 10 * pixelScale, yTickWidthOnScreen
	);

	ctx.textBaseline = 'top';
	ctx.textAlign = 'start';
	//top left coords
	ctx.fillText('(' + round(graph.x.min) + ', ' + round(graph.y.max) + ')',
		0, 0);
	ctx.textBaseline = 'bottom';
	//center coords
	ctx.fillText('(0, 0)', graphToScreenX(0) + 2 * pixelScale, graphToScreenY(0) - 2 * pixelScale);
	ctx.textAlign = 'end';
	//bottom right coords
	ctx.fillText('(' + round(graph.x.max) + ', ' + round(graph.y.min) + ')',
		ctx.x, ctx.y);
}

function render(time) {
	let x, y;
	ctx.clearRect(0, 0, ctx.x, ctx.y);
	renderDecoration();

	renderGrid();
	renderSolution();

	frame++;
	//if(!touched || continuous) {
		//window.requestAnimationFrame(render);
	//}
}

function calibrateGraph() {
	//re calculate keys of graph
	graph.x.range  = +$('width-value').value;
	graph.x.center = +$('center-x-value').value;
	graph.x.min = graph.x.center - graph.x.range / 2;
	graph.x.max = graph.x.center + graph.x.range / 2;
	graph.y.range  = +$('height-value').value;
	graph.y.center = +$('center-y-value').value;
	graph.y.min = graph.y.center - graph.y.range / 2;
	graph.y.max = graph.y.center + graph.y.range / 2;
}

function updateScroll(e) {
	let width = +$('width-value').value;
	let height = +$('height-value').value;

	let scale;
	if(e.type == 'wheel') {
		scale = e.deltaY > 0 ? 1.1 : 0.9;
	} else {
		//touch
	}

	$('width-value').value  = $('width-range').value  = (width * scale).toPrecision(3);
	$('height-value').value = $('height-range').value = (height * scale).toPrecision(3);
	calibrateGraph();
}

function dist(x1, x2, y1, y2) {
	return  Math.sqrt(
		Math.pow(x2 - x1, 2) +
		Math.pow(y2 - y1, 2)
	);
}

function distsqr(x1, y1, x2, y2) {
	return  Math.pow(x2 - x1, 2) +
		Math.pow(y2 - y1, 2);
}

// updates cursor position for when the cursor is moved at any point
function updateCursor(e) {
	if((e.type == 'mousemove') || (e.type == 'wheel')) {
		cursor.x = e.offsetX * pixelScale / ctx.x
			* graph.x.range + graph.x.min;
		cursor.y = (ctx.y - e.offsetY * pixelScale) / ctx.y
			* graph.y.range + graph.y.min;
	} else if(e.type == 'touchmove') {
		//touch event
		cursor.x = (
			graph.x.range
			* pixelScale
			* (e.touches[0].clientX - e.srcElement.offsetLeft)
			/ ctx.x
			+ graph.x.min
		);
		cursor.y = (
			graph.y.range
			* (ctx.y
			- (e.touches[0].clientY - e.srcElement.offsetTop)
			* pixelScale)
			/ ctx.y
			+ graph.y.min
		);
	}
	console.log(cursor.x.toPrecision(3) + " " + cursor.y.toPrecision(3));
}

// moves the graph around when the cursor is moved *while* clicking /
// touching the canvas
function updateCursorMovement(e) {
	let cx = +$('center-x-value').value;
	let cy = +$('center-y-value').value;
	let dx, dy;

	if((e.type == 'mousemove') || (e.type == 'wheel')) {
		//deltas are negative, but y axis is flipped, so we only
		//flip the x axis
		dx = -graph.x.range * e.movementX / ctx.x;
		dy =  graph.y.range * e.movementY / ctx.y;
	} else if(e.type == 'touchmove') {
		if(e.touches.length < lastTouch.count) {
			return;
		}
		//touch
		//console.log(e.touches[0].pageX + " " + e.touches[0].pageY);
		dx = -graph.x.range * (e.touches[0].pageX - lastTouch.x)
			* pixelScale / ctx.x;
		dy = graph.y.range * (e.touches[0].pageY - lastTouch.y)
			* pixelScale / ctx.y;
		lastTouch.x = e.touches[0].pageX;
		lastTouch.y = e.touches[0].pageY;
		if(e.touches.length > 1) {
			// zooming in/out
			let currentDist = distsqr(
				e.touches[0].pageX, e.touches[0].pageY,
				e.touches[1].pageX, e.touches[1].pageY
			);
			let scale = lastTouch.dist / currentDist;
			lastTouch.dist = currentDist;
			let width = +$('width-value').value;
			let height = +$('height-value').value;
			$('width-value').value  = $('width-range').value  = (width * scale).toPrecision(3);
			$('height-value').value = $('height-range').value = (height * scale).toPrecision(3);
			calibrateGraph();
		}
	}

	$('center-x-value').value = $('center-x-range').value = cx + dx;
	$('center-y-value').value = $('center-y-range').value = cy + dy;
	calibrateGraph();
}

function calibrateFormula() {
	formula = $('formula-input').value;
	if(!gotIt) {
		if(formula.indexOf('^') != -1) {
			//there's a ^ in the eq
			$('formula-note').style.display = 'block';
		} else {
			$('formula-note').style.display = 'none';
		}
	}
	// 2log10(5y) ⇒ 2 * log10(5 * y)
	formula = formula.replace(/(\d+)(\w+)/gi, '$1 * $2');
	formula = formula.replace(/·/g, '*');
	formula = formula.replace(/\bln\b/gi, 'Math.log');
	formula = formula.replace(/\bt\b/gi, '(performance.now() / 1000)');
	// (x - 1)(x + 3) ⇒ (x - 1) * (x + 3)
	formula = formula.replace(/\)\(/g, ')*(');

	let descriptors = Object.getOwnPropertyDescriptors(Math);
	for(let val in descriptors) {
		let v = descriptors[val].value;
		if(typeof(v) === 'function') {
			formula = formula.replace(
				new RegExp('\\b' + v.name.toLowerCase()
				+ '\\b', 'gi'),
				'Math.' + v.name
			);
			if(v.length == 1) {
				// 1 arg means we can replace stuff like
				// sinx and sin y with Math.sin(x) etc.
				formula = formula.replace(
					new RegExp('\\b' + v.name.toLowerCase()
					+ '\\s*([xy])\\b', 'gi'),
					'Math.' + v.name + '($1)'
				);
			}
		} else if(typeof(v) === 'number') {
			// constant like e or π
			formula = formula.replace(
				new RegExp('\\b' + val + '\\b', 'gi'),
				'Math.' + val
			);
		}
	}

	// word chars surrounded by space = multiplication
	// like tanx siny
	formula = formula.replace(/(\w|\))\s+(\w|\()/g, '$1 * $2');
}

function setEqFromURL() {
	// strip leading `#`, decode
	// short delay so the url can update before we grab it
	// default to y + sin(x) in case we have a null-ish false-ish value
	window.setTimeout(() => {
		$('formula-input').value = window.decodeURIComponent(
			document.location.hash.substr(1)
		) || "y + sin(x)";
		calibrateFormula();
		window.requestAnimationFrame(render);
	}, 20);
}

function reset() {
	calibrateGraph();
	calibrateFormula();
}

function init() {
	//initialize cvs, ctx, etc
	let frameWidth, frameHeight;
	pixelScale = window.devicePixelRatio;
	let maxWidth = document.body.clientwidth * pixelScale;
	if(maxWidth < 500) {
		frameWidth = maxWidth * pixelScale;
	} else {
		frameWidth  = 500 * pixelScale;
	}
	frameHeight = frameWidth;
	gridSpacing = +$('grid-spacing-value').value;
	cursorTracking = false;
	continuous = false;
	touched = true;
	gotIt = false;
	frame = 0;

	lastTouch = { x: 0, y: 0, dist: 0 };
	cursor = {x: 0, y: 0};

	graph = {
		x: {
			range:  0,
			min:    0,
			max:    0,
			center: 0
		},
		y: {
			range:  0,
			min:    0,
			max:    0,
			center: 0
		}
	};

	step = 1;

	cvs = $('main-canvas');

	cvs.setAttribute('height', frameHeight + 'px');
	cvs.setAttribute('width',  frameWidth + 'px');
	ctx = cvs.getContext('2d')
	ctx.width  = frameWidth;
	ctx.height = frameWidth;
	ctx.x = frameWidth;
	ctx.y = frameHeight;
	cvs.style.height = frameHeight / pixelScale + 'px';
	cvs.style.width =  frameWidth / pixelScale + 'px';
	ctx.lineWidth = pixelScale;

	ctx.fontFamily = '"Segoe UI", -apple-system, "Helvetica", "Segoe UI Emoji", "Apple Color Emoji", "Noto Color Emoji", "Noto Sans",  "FreeSans", "Code2001", "Code2000", "DejaVu Sans",  sans-serif';
	ctx.font = 16 * pixelScale + 'px ' + ctx.fontFamily;


	setEqFromURL();
	reset();

	cvs.onwheel = e => {
		updateScroll(e);
		updateCursor(e);
		if(touched) {
			window.requestAnimationFrame(render);
		}
		return false;
	};

	cvs.onmousemove = e => {
		updateCursor(e);
		if(cursorTracking) {
			updateCursorMovement(e);
		}
		if(touched) {
			window.requestAnimationFrame(render);
		}
	};

	cvs.onmousedown = e => {
		cvs.style.cursor = '-webkit-grabbing';
		cursorTracking = true;
	};

	cvs.onmouseup = cvs.onmouseout = e => {
		cvs.style.cursor = '-webkit-grab';
		cursorTracking = false;
	};

	cvs.ontouchmove = e => {
		updateCursor(e);
		updateCursorMovement(e);
		if(touched) {
			window.requestAnimationFrame(render);
		}
		return false;
	};

	cvs.ontouchstart = e => {
		e.preventDefault();
		cursorTracking = true;
		lastTouch.x = e.touches[0].pageX;
		lastTouch.y = e.touches[0].pageY;
		if(e.touches.length > 1) {
			lastTouch.dist = distsqr(
				e.touches[0].pageX, e.touches[0].pageY,
				e.touches[1].pageX, e.touches[1].pageY
			);
		}
		lastTouch.count = e.touches.length;
		updateCursor(e);
	};

	cvs.ontouchend = e => {
		cursorTracking = false;
	};

	$('grid-spacing-range').oninput = $('grid-spacing-range').onchange = e => {
		$('grid-spacing-value').value = e.target.value;
		gridSpacing = e.target.value;
		if(touched) {
			window.requestAnimationFrame(render);
		}
	}

	$('grid-spacing-value').oninput = $('grid-spacing-value').onchange = e => {
		$('grid-spacing-range').value = e.target.value;
		gridSpacing = e.target.value;
		if(touched) {
			window.requestAnimationFrame(render);
		}
	}

	$('formula-input').oninput = $('formula-input').onchange = e => {
		window.location.hash = "#" + window.encodeURIComponent(
			$('formula-input').value
		);
		calibrateFormula();
		if(touched) {
			window.requestAnimationFrame(render);
		}
	};

	$('got-it').onclick = e => {
		$('formula-note').remove();
		gotIt = true;
	};

	window.requestAnimationFrame(render);
};

</script>
